int balancer_ingress(struct xdp_md * ctx):
0xffffffffc06321b8:
; int balancer_ingress(struct xdp_md *ctx) {
   0:	push   %rbp
   1:	mov    %rsp,%rbp
   4:	sub    $0x80,%rsp
   b:	push   %rbx
   c:	push   %r13
   e:	push   %r14
  10:	push   %r15
  12:	pushq  $0x0
  14:	mov    %rdi,%r14
  17:	mov    $0x1,%ebx
; void *data_end = (void *)(long)ctx->data_end;
  1c:	mov    0x8(%r14),%rsi
; void *data = (void *)(long)ctx->data;
  20:	mov    0x0(%r14),%rdi
; if (data + nh_off > data_end) {
  24:	mov    %rdi,%rdx
  27:	add    $0xe,%rdx
; if (data + nh_off > data_end) {
  2b:	cmp    %rsi,%rdx
  2e:	ja     0x0000000000000554
  34:	mov    $0x2,%ebx
; eth_proto = eth->eth_proto;
  39:	movzwq 0xc(%rdi),%rdx
; if (eth_proto == BE_ETH_P_IP) {
  3e:	cmp    $0x8,%rdx
  42:	jne    0x0000000000000554
  48:	xor    %edx,%edx
; struct packet_description pckt = {};
  4a:	mov    %rdx,-0x10(%rbp)
  4e:	mov    %rdx,-0x18(%rbp)
  52:	mov    %rdx,-0x20(%rbp)
  56:	mov    %rdx,-0x28(%rbp)
  5a:	mov    %rdx,-0x30(%rbp)
  5e:	mov    %rdx,-0x38(%rbp)
; struct vip_definition vip = {};
  62:	mov    %edx,-0x40(%rbp)
  65:	mov    %rdx,-0x48(%rbp)
  69:	mov    %rdx,-0x50(%rbp)
; __u32 mac_addr_pos = 0;
  6d:	mov    %edx,-0x54(%rbp)
; if (iph + 1 > data_end) {
  70:	mov    %rdi,%rdx
  73:	add    $0x22,%rdx
; 
  77:	mov    $0x1,%ebx
; if (iph + 1 > data_end) {
  7c:	cmp    %rsi,%rdx
  7f:	ja     0x0000000000000554
; pckt->tos = iph->tos;
  85:	movzbq 0xf(%rdi),%rdx
; pckt->tos = iph->tos;
  8a:	mov    %dl,-0xb(%rbp)
; *protocol = iph->protocol;
  8d:	movzbq 0x17(%rdi),%rdx
; pckt->flow.proto = *protocol;
  92:	mov    %dl,-0x14(%rbp)
; if (iph->frag_off & PCKT_FRAGMENTED) {
  95:	movzwq 0x14(%rdi),%rcx
; if (iph->frag_off & PCKT_FRAGMENTED) {
  9a:	and    $0xff3f,%rcx
; 
  a1:	mov    $0x1,%ebx
; if (iph->frag_off & PCKT_FRAGMENTED) {
  a6:	cmp    $0x0,%rcx
  aa:	jne    0x0000000000000554
; 
  b0:	mov    $0x2,%ebx
; if (*protocol == IPPROTO_ICMP) {
  b5:	cmp    $0x1,%rdx
  b9:	je     0x0000000000000554
  bf:	movzwq 0x10(%rdi),%r15
; pckt->flow.src = iph->saddr;
  c4:	mov    0x1a(%rdi),%ecx
; pckt->flow.src = iph->saddr;
  c7:	mov    %ecx,-0x38(%rbp)
; pckt->flow.dst = iph->daddr;
  ca:	mov    0x1e(%rdi),%ecx
; pckt->flow.dst = iph->daddr;
  cd:	mov    %ecx,-0x28(%rbp)
; 
  d0:	mov    $0x2,%ebx
; if (protocol == IPPROTO_TCP) {
  d5:	cmp    $0x11,%rdx
  d9:	jne    0x0000000000000554
; if (udp + 1 > data_end) {
  df:	mov    %rdi,%rdx
  e2:	add    $0x2a,%rdx
; 
  e6:	mov    $0x1,%ebx
; if (udp + 1 > data_end) {
  eb:	cmp    %rsi,%rdx
  ee:	ja     0x0000000000000554
; pckt->flow.port16[0] = udp->source;
  f4:	movzwq 0x22(%rdi),%rsi
; pckt->flow.port16[0] = udp->source;
  f9:	mov    %si,-0x18(%rbp)
; pckt->flow.port16[1] = udp->dest;
  fd:	movzwq 0x24(%rdi),%rdi
 102:	mov    $0x11,%esi
; vip.proto = pckt.flow.proto;
 107:	mov    %sil,-0x3e(%rbp)
; vip.vip = pckt.flow.dst;
 10b:	mov    %ecx,-0x50(%rbp)
; vip.port = pckt.flow.port16[1];
 10e:	mov    %di,-0x40(%rbp)
; pckt->flow.port16[1] = udp->dest;
 112:	mov    %di,-0x16(%rbp)
 116:	mov    %rbp,%rsi
; struct packet_description pckt = {};
 119:	add    $0xffffffffffffffb0,%rsi
; vip_info = bpf_map_lookup_elem(&vip_map, &vip); //XXX MAPPA
 11d:	movabs $0xffff901835a8a400,%rdi
 127:	callq  0xffffffffee9b8e48
 12c:	cmp    $0x0,%rax
 130:	je     0x0000000000000136
 132:	add    $0x48,%rax
 136:	mov    %rax,%r13
; if (!vip_info) { 
 139:	cmp    $0x0,%r13
 13d:	jne    0x0000000000000177
 13f:	xor    %edi,%edi
; vip.port = 0;
 141:	mov    %di,-0x40(%rbp)
 145:	mov    %rbp,%rsi
 148:	add    $0xffffffffffffffb0,%rsi
; vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 14c:	movabs $0xffff901835a8a400,%rdi
 156:	callq  0xffffffffee9b8e48
 15b:	cmp    $0x0,%rax
 15f:	je     0x0000000000000165
 161:	add    $0x48,%rax
 165:	mov    %rax,%r13
; 
 168:	mov    $0x2,%ebx
; if (!vip_info) {
 16d:	cmp    $0x0,%r13
 171:	je     0x0000000000000554
 177:	mov    $0x200,%edi
; __u32 stats_key = MAX_VIPS + LRU_CNTRS;
 17c:	mov    %edi,-0x58(%rbp)
 17f:	mov    %rbp,%rsi
; struct vip_meta *vip_info;
 182:	add    $0xffffffffffffffa8,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &stats_key); //XXX MAPPA
 186:	movabs $0xffff9018351f0000,%rdi
 190:	callq  0xffffffffee9bb1b8
 195:	mov    $0x1,%ebx
; if (!data_stats) {
 19a:	cmp    $0x0,%rax
 19e:	je     0x0000000000000554
; data_stats->v1 += 1;
 1a4:	mov    0x0(%rax),%rdi
 1a8:	add    $0x1,%rdi
 1ac:	mov    %rdi,0x0(%rax)
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 1b0:	movzbq 0x0(%r13),%rdi
 1b5:	and    $0x1,%rdi
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 1b9:	cmp    $0x0,%rdi
 1bd:	je     0x00000000000001c5
 1bf:	xor    %edi,%edi
; pckt.flow.port16[0] = 0;
 1c1:	mov    %di,-0x18(%rbp)
; __u32 cpu_num = bpf_get_smp_processor_id(); //XXX HELPER
 1c5:	callq  0xffffffffee9b7708
; __u32 cpu_num = bpf_get_smp_processor_id(); //XXX HELPER
 1ca:	mov    %eax,-0x5c(%rbp)
 1cd:	mov    %rbp,%rsi
; __u32 cpu_num = bpf_get_smp_processor_id(); //XXX HELPER
 1d0:	add    $0xffffffffffffffa4,%rsi
; void *lru_map = bpf_map_lookup_elem(&lru_maps_mapping, &cpu_num); //XXX MAPPA
 1d4:	movabs $0xffff90183878c000,%rdi
 1de:	add    $0xd0,%rdi
 1e5:	mov    0x0(%rsi),%eax
 1e8:	cmp    $0x80,%rax
 1ef:	jae    0x0000000000000204
 1f1:	shl    $0x3,%rax
 1f5:	add    %rdi,%rax
 1f8:	mov    0x0(%rax),%rax
 1fc:	cmp    $0x0,%rax
 200:	je     0x0000000000000204
 202:	jmp    0x0000000000000206
 204:	xor    %eax,%eax
; if (!lru_map) {
 206:	cmp    $0x0,%rax
 20a:	je     0x0000000000000554
; if (!(pckt.flags & F_SYN_SET) &&
 210:	movzbq -0xc(%rbp),%rdi
; if (!(pckt.flags & F_SYN_SET) &&
 215:	and    $0x2,%rdi
; if (!(pckt.flags & F_SYN_SET) &&
 219:	cmp    $0x0,%rdi
 21d:	jne    0x0000000000000554
; !(vip_info->flags & F_LRU_BYPASS)) {
 223:	movzbq 0x0(%r13),%rdi
 228:	and    $0x2,%rdi
; if (!(pckt.flags & F_SYN_SET) &&
 22c:	cmp    $0x0,%rdi
 230:	jne    0x0000000000000554
 236:	mov    %rbp,%rsi
; struct packet_description *pckt,
 239:	add    $0xffffffffffffffc8,%rsi
; dst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow); //XXX MAPPA  
 23d:	mov    %rax,%rdi
 240:	callq  0xffffffffee9b8e48
 245:	cmp    $0x0,%rax
 249:	je     0x000000000000025e
 24b:	movzbq 0x23(%rax),%rdi
 250:	cmp    $0x0,%rdi
 254:	jne    0x000000000000025a
 256:	movb   $0x1,0x23(%rax)
 25a:	add    $0x58,%rax
; if (!dst_lru) {
 25e:	cmp    $0x0,%rax
 262:	jne    0x0000000000000269
 264:	jmpq   0x0000000000000554
; if (pckt->flow.proto == IPPROTO_UDP) {
 269:	movzbq -0x14(%rbp),%rdi
; if (pckt->flow.proto == IPPROTO_UDP) {
 26e:	cmp    $0x11,%rdi
 272:	jne    0x0000000000000289
 274:	mov    %rax,-0x68(%rbp)
; cur_time = bpf_ktime_get_ns(); //XXX HELPER
 278:	callq  0xffffffffee9b7828
; dst_lru->atime = cur_time;
 27d:	mov    -0x68(%rbp),%rdi
 281:	mov    %rax,0x8(%rdi)
 285:	mov    -0x68(%rbp),%rax
; key = dst_lru->pos;
 289:	mov    0x0(%rax),%edi
; pckt->real_index = key;
 28c:	mov    %edi,-0x10(%rbp)
; key = dst_lru->pos;
 28f:	mov    %edi,-0x4(%rbp)
 292:	mov    %rbp,%rsi
; key = dst_lru->pos;
 295:	add    $0xfffffffffffffffc,%rsi
; *real = bpf_map_lookup_elem(&reals, &key); //XXX MAPPA
 299:	movabs $0xffffa74a40b39000,%rdi
 2a3:	add    $0xd0,%rdi
 2aa:	mov    0x0(%rsi),%eax
 2ad:	cmp    $0x1000,%rax
 2b4:	jae    0x00000000000002c8
 2b6:	push   %rdx
 2b7:	mov    %rax,%r11
 2ba:	mov    $0x18,%eax
 2bf:	mul    %r11
 2c2:	pop    %rdx
 2c3:	add    %rdi,%rax
 2c6:	jmp    0x00000000000002ca
 2c8:	xor    %eax,%eax
 2ca:	mov    %rax,-0x68(%rbp)
 2ce:	cmp    $0x0,%rax
 2d2:	je     0x0000000000000554
 2d8:	mov    %rbp,%rsi
; cval = bpf_map_lookup_elem(&ctl_array, &mac_addr_pos); //XXX MAPPA
 2db:	add    $0xffffffffffffffac,%rsi
 2df:	movabs $0xffff9018371d8e00,%rdi
 2e9:	add    $0xd0,%rdi
 2f0:	mov    0x0(%rsi),%eax
 2f3:	cmp    $0x10,%rax
 2f7:	jae    0x0000000000000302
 2f9:	shl    $0x3,%rax
 2fd:	add    %rdi,%rax
 300:	jmp    0x0000000000000304
 302:	xor    %eax,%eax
 304:	mov    %rax,-0x70(%rbp)
; if (!cval) {
 308:	cmp    $0x0,%rax
 30c:	je     0x0000000000000554
; if (dst->flags & F_IPV6) {
 312:	mov    -0x68(%rbp),%rdi
 316:	movzbq 0x10(%rdi),%rdi
; if (dst->flags & F_IPV6) {
 31b:	and    $0x1,%rdi
; if (dst->flags & F_IPV6) {
 31f:	cmp    $0x0,%rdi
 323:	jne    0x0000000000000554
; __u32 ip_suffix = bpf_htons(pckt->flow.port16[0]); //XXX HELPER
 329:	movzwq -0x18(%rbp),%rdi
; ip_suffix ^= pckt->flow.src;
 32e:	mov    %rdi,-0x78(%rbp)
 332:	mov    -0x38(%rbp),%edi
; if (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(struct iphdr))) { //XXX HELPER
 335:	mov    %rdi,-0x80(%rbp)
 339:	mov    %r14,%rdi
 33c:	mov    $0xffffffec,%esi
 341:	callq  0xffffffffef0ee118
 346:	shl    $0x20,%rax
 34a:	shr    $0x20,%rax
; if (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(struct iphdr))) { //XXX HELPER
 34e:	cmp    $0x0,%rax
 352:	jne    0x0000000000000554
; data = (void*)(long)xdp->data;
 358:	mov    0x0(%r14),%rdi
; data_end = (void*)(long)xdp->data_end;
 35c:	mov    0x8(%r14),%rsi
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
 360:	mov    %rdi,%rdx
 363:	add    $0xe,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
 367:	cmp    %rsi,%rdx
 36a:	ja     0x0000000000000554
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
 370:	mov    %rdi,%rdx
 373:	add    $0x22,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
 377:	cmp    %rsi,%rdx
 37a:	ja     0x0000000000000554
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
 380:	cmp    %rsi,%rdx
 383:	ja     0x0000000000000554
 389:	ror    $0x8,%r15w
 38e:	movzwl %r15w,%r15d
 392:	mov    -0x78(%rbp),%rax
 396:	bswap  %eax
 398:	mov    $0xffff0000,%esi
 39d:	and    %rsi,%rax
; 
 3a0:	mov    %rdi,%rsi
 3a3:	add    $0x14,%rsi
 3a7:	mov    -0x70(%rbp),%rcx
; memcpy(new_eth->eth_dest, cval->mac, 6);
 3ab:	movzwq 0x4(%rcx),%rdx
 3b0:	mov    %dx,0x4(%rdi)
 3b4:	movzwq 0x2(%rcx),%rdx
 3b9:	mov    %dx,0x2(%rdi)
 3bd:	movzwq 0x0(%rcx),%rdx
 3c2:	mov    %dx,0x0(%rdi)
; memcpy(new_eth->eth_source, old_eth->eth_dest, 6);
 3c6:	movzwq 0x0(%rsi),%rdx
 3cb:	movzwq 0x2(%rsi),%rcx
 3d0:	movzwq 0x4(%rsi),%rsi
 3d5:	mov    $0x8,%r8d
; new_eth->eth_proto = BE_ETH_P_IP;
 3db:	mov    %r8w,0xc(%rdi)
; memcpy(new_eth->eth_source, old_eth->eth_dest, 6);
 3e0:	mov    %si,0xa(%rdi)
 3e4:	mov    %cx,0x8(%rdi)
 3e8:	mov    %dx,0x6(%rdi)
 3ec:	mov    -0x80(%rbp),%rsi
; ((0xFFFF0000 & ip_suffix) | IPIP_V4_PREFIX),
 3f0:	and    $0xffffffffffff0000,%rsi
 3f7:	xor    %rsi,%rax
; dst->dst,
 3fa:	mov    -0x68(%rbp),%rsi
 3fe:	mov    0x0(%rsi),%edx
; pckt->tos,
 401:	movzbq -0xb(%rbp),%rsi
 406:	mov    $0x45,%ecx
; iph->ihl = 5;
 40b:	mov    %cl,0xe(%rdi)
; iph->tos = tos;
 40e:	mov    %sil,0xf(%rdi)
 412:	mov    $0x440,%esi
; iph->ttl = DEFAULT_TTL;
 417:	mov    %si,0x16(%rdi)
 41b:	xor    %esi,%esi
; iph->frag_off = 0;
 41d:	mov    %si,0x14(%rdi)
 421:	mov    $0xffff0000,%esi
; ((0xFFFF0000 & ip_suffix) | IPIP_V4_PREFIX),
 426:	mov    %rax,%rcx
 429:	and    %rsi,%rcx
; *csum += *next_iph_u16++;
 42c:	shr    $0x10,%rcx
; iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
 430:	mov    %r15,%rsi
 433:	add    $0x14,%rsi
 437:	ror    $0x8,%si
 43b:	movzwl %si,%esi
; iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
 43e:	mov    %si,0x10(%rdi)
; *csum += *next_iph_u16++;
 442:	add    %rcx,%rsi
; ((0xFFFF0000 & ip_suffix) | IPIP_V4_PREFIX),
 445:	or     $0x10ac,%rax
; iph->saddr = saddr;
 44b:	mov    %eax,0x1a(%rdi)
; *csum += *next_iph_u16++;
 44e:	mov    %rdx,%rcx
 451:	and    $0xffff,%rcx
; *csum += *next_iph_u16++;
 458:	add    %rcx,%rsi
; iph->daddr = daddr;
 45b:	mov    %edx,0x1e(%rdi)
; *csum += *next_iph_u16++;
 45e:	shr    $0x10,%rdx
; *csum += *next_iph_u16++;
 462:	add    %rdx,%rsi
; *csum += *next_iph_u16++;
 465:	movzwq 0xe(%rdi),%rdx
; *csum += *next_iph_u16++;
 46a:	add    %rdx,%rsi
; *csum += *next_iph_u16++;
 46d:	movzwq 0x12(%rdi),%rdx
; *csum += *next_iph_u16++;
 472:	add    %rdx,%rsi
; *csum += *next_iph_u16++;
 475:	movzwq 0x16(%rdi),%rdx
; *csum += *next_iph_u16++;
 47a:	add    %rdx,%rsi
 47d:	add    $0x10ac,%rsi
; if (csum >> 16)
 484:	mov    %rsi,%rdx
 487:	shr    $0x10,%rdx
; if (csum >> 16)
 48b:	cmp    $0x0,%rdx
 48f:	je     0x000000000000049b
 491:	and    $0xffff,%rsi
 498:	add    %rdx,%rsi
; if (csum >> 16)
 49b:	mov    %rsi,%rdx
 49e:	shr    $0x10,%rdx
; if (csum >> 16)
 4a2:	cmp    $0x0,%rdx
 4a6:	je     0x00000000000004b2
 4a8:	and    $0xffff,%rsi
 4af:	add    %rdx,%rsi
; if (csum >> 16)
 4b2:	mov    %rsi,%rdx
 4b5:	shr    $0x10,%rdx
; if (csum >> 16)
 4b9:	cmp    $0x0,%rdx
 4bd:	je     0x00000000000004c9
 4bf:	and    $0xffff,%rsi
 4c6:	add    %rdx,%rsi
; if (csum >> 16)
 4c9:	mov    %rsi,%rdx
 4cc:	shr    $0x10,%rdx
; if (csum >> 16)
 4d0:	add    %rsi,%rdx
; iph->check = csum;
 4d3:	xor    $0xffffffffffffffff,%rdx
; iph->check = csum;
 4d7:	mov    %dx,0x18(%rdi)
; vip_num = vip_info->vip_num;
 4db:	mov    0x4(%r13),%edi
; vip_num = vip_info->vip_num;
 4df:	mov    %edi,-0x4(%rbp)
 4e2:	mov    %rbp,%rsi
; static inline __u16 csum_fold_helper(__u64 csum) {
 4e5:	add    $0xfffffffffffffffc,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &vip_num); //XXX MAPPA
 4e9:	movabs $0xffff9018351f0000,%rdi
 4f3:	callq  0xffffffffee9bb1b8
; if (!data_stats) {
 4f8:	cmp    $0x0,%rax
 4fc:	je     0x0000000000000554
; data_stats->v1 += 1;
 4fe:	mov    %rbp,%rsi
 501:	add    $0xfffffffffffffff0,%rsi
 505:	mov    0x8(%rax),%rdi
 509:	mov    %r15,%rdx
 50c:	add    %rdi,%rdx
 50f:	mov    %rdx,0x8(%rax)
 513:	mov    0x0(%rax),%rdi
 517:	add    $0x1,%rdi
 51b:	mov    %rdi,0x0(%rax)
; data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index); //XXX MAPPA
 51f:	movabs $0xffffa74a4095d000,%rdi
 529:	callq  0xffffffffee9bb1b8
 52e:	mov    $0x1,%ebx
; if (!data_stats) {
 533:	cmp    $0x0,%rax
 537:	je     0x0000000000000554
; data_stats->v1 += 1;
 539:	mov    0x8(%rax),%rdi
 53d:	add    %rdi,%r15
 540:	mov    %r15,0x8(%rax)
 544:	mov    0x0(%rax),%rdi
 548:	add    %rdi,%rbx
 54b:	mov    %rbx,0x0(%rax)
 54f:	mov    $0x3,%ebx
; }
 554:	mov    %rbx,%rax
 557:	pop    %rbx
 558:	pop    %r15
 55a:	pop    %r14
 55c:	pop    %r13
 55e:	pop    %rbx
 55f:	leaveq 
 560:	retq   

